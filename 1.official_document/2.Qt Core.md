# Qt Core


The Qt Core module adds these features to C++:
* a very powerful mechanism for seamless object communication called **signals and slots**
* queryable and designable object properties
* hierarchical and queryable object trees that organize
* object ownership in a natural way with guarded pointers (**QPointer**)
* a dynamic cast that works across library boundaries



The following pages provide more information about Qt's core features:
The Meta-Object System https://doc.qt.io/qt-6.2/metaobjects.html
The Property System https://doc.qt.io/qt-6.2/properties.html
Object Model https://doc.qt.io/qt-6.2/object.html
Object Trees & Ownership https://doc.qt.io/qt-6.2/objecttrees.html
Signals & Slots https://doc.qt.io/qt-6.2/signalsandslots.html



## Using the Module
Using a Qt module requires linking against the module library, either directly or through other dependencies.
Several build tools have dedicated support for this, including CMake and qmake.

### Building with CMake
Use the `find_package()` command to locate the needed module components in the Qt6 package:
```cmake
find_package(Qt6 REQUIRED COMPONENTS Core)
target_link_libraries(mytarget PRIVATE Qt6::Core)
```
See also the Build with CMake overview.

https://doc.qt.io/qt-6.2/cmake-manual.html

### Building with qmake
If you use qmake to build your projects, Qt6Core is linked by default.





## Threading and Concurrent Programming
Qt provides thread support in the form of platform-independent **threading classes**, a thread-safe way of posting events, and signal-slot connections across threads. 
Multithreaded programming is also a useful paradigm for performing time-consuming operations without freezing the user interface of an application.

The Thread Support in Qt page contains information on implementing threads in applications. Additional concurrent classes are provided by the Qt Concurrent module.

https://doc.qt.io/qt-6.2/threads.html



## Input/Output, Resources, and Containers
Qt provides a resource system for organizing application files and assets, a set of containers, and classes for receiving input and printing output.
* Container Classes
* Serializing Qt Data Types
* Implicit Sharing

In addition, Qt Core provides a platform-independent mechanism for storing binary files in the application's executable.
* The Qt Resource System





## Additional Frameworks

Qt Core also provides some of Qt's key frameworks.
* The Animation Framework
* JSON Support in Qt
* How to Create Qt Plugins
* The Event System




## Module Evolution
Changes to Qt Core lists important changes in the module API and functionality that were done for the Qt 6 series of Qt.

https://doc.qt.io/qt-6.2/qtcore-changes-qt6.html


## Licenses and Attributions
Qt Core is available under commercial licenses from The Qt Company. 
In addition, it is available under free software licenses: The GNU Lesser General Public License, version 3, or the GNU General Public License, version 2. 
See Qt Licensing for further details.

https://doc.qt.io/qt-6.2/licensing.html


Executables on Windows potentially link against The QtEntryPoint Library. 
This library is available under commercial licenses and also under the BSD 3-clause "New" or "Revised" License.

Furthermore, Qt Core in Qt 6.2.7 may contain third party modules under following permissive licenses:
* BLAKE2 (reference implementation), version 54f4faa4c16ea34bcd59d16e8da46a64b259fc07
	* Creative Commons Zero v1.0 Universal or Apache License 2.0
* Data Compression Library (zlib), version 1.2.13
	* zlib License
* Easing Equations by Robert Penner
	* BSD 3-clause "New" or "Revised" License
* Efficient Binary-Decimal and Decimal-Binary Conversion Routines for IEEE Doubles, version 3.1.5-30-gbf46072
	* BSD 3-clause "New" or "Revised" License
* FreeBSD strtoll and strtoull, version 18b29f3fb8abee5d57ed8f4a44f806bec7e0eeff
	* BSD 3-clause "New" or "Revised" License
* KWin, version 5.13.4
	* BSD-3-Clause
* KWin, version 5.13.4
	* BSD-3-Clause
* MD4
	* Public Domain
* MD5
	* Public Domain
* PCRE2 - Stack-less Just-In-Time Compiler, version 10.40
	* BSD 2-clause "Simplified" License
* PCRE2, version 10.40
	* BSD 3-clause "New" or "Revised" License
* QEventDispatcher on macOS
	* BSD 3-clause "New" or "Revised" License
* Secure Hash Algorithm SHA-1
	* Public Domain
* Secure Hash Algorithm SHA-3 - Keccak, version 3.2
	* Creative Commons Zero v1.0 Universal
* Secure Hash Algorithm SHA-3 - brg_endian, version https://github.com/BrianGladman/sha/ commit 4b9e13ead2c5b5e41ca27c65de4dd69ae0bac228
	* BSD 2-clause "Simplified" License
* Secure Hash Algorithms SHA-384 and SHA-512
	* BSD 3-clause "New" or "Revised" License
* SipHash Algorithm
	* Creative Commons Zero v1.0 Universal
* The Public Suffix List, version d17a65633b0286833727ef21e897a22564695ef5, fetched on 2022-05-23
	* Mozilla Public License 2.0
* TinyCBOR, version 0.6+patches
	* MIT License
* Unicode Character Database (UCD), version 26
	* Unicode License Agreement - Data Files and Software (2016)
* Unicode Common Locale Data Repository (CLDR), version v40
	* Unicode License Agreement - Data Files and Software (2016)
* extra-cmake-modules, version 5.84.0
	* BSD-3-Clause
* extra-cmake-modules, version 5.84.0
	* BSD-3-Clause
* forkfd
	* MIT License




## Reference
These are links to the API reference materials.
C++ Classes
* Animation Classes
* Threading Classes
* Container Classes
* Plugin Classes
* Implicitly Shared Classes
* Input/Output Classes
* Event Classes

CMake API
* CMake Commands
* CMake Variables
* CMake Target Properties


https://doc.qt.io/qt-6.2/qtcore-module.html


# The Meta-Object System


Qt's meta-object system provides the signals and slots mechanism for inter-object communication, run-time type information, and the dynamic property system.

The meta-object system is based on three things:
1. The `QObject` class provides a base class for objects that can take advantage of the meta-object system.
2. The `Q_OBJECT` macro inside the private section of the class declaration is used to enable meta-object features, such as dynamic properties, signals, and slots.
3. The **Meta-Object Compiler (moc)** supplies each QObject subclass with the necessary code to implement meta-object features.


The **moc** tool reads a C++ source file. 
If it finds one or more class declarations that contain the `Q_OBJECT` macro, it produces another C++ source file which contains the meta-object code for each of those classes. 
This generated source file is either `#include`'d into the class's source file or, more usually, compiled and linked with the class's implementation.

In addition to providing the **signals and slots** mechanism for communication between objects (the main reason for introducing the system), the meta-object code provides the following additional features:
* `QObject::metaObject()` returns the associated meta-object for the class.
* `QMetaObject::className()` returns the class name as a string at run-time, without requiring native run-time type information (RTTI) support through the C++ compiler.
* `QObject::inherits()` function returns whether an object is an instance of a class that inherits a specified class within the QObject inheritance tree.
* `QObject::tr()` translates strings for internationalization.
* `QObject::setProperty()` and `QObject::property()` dynamically set and get properties by name.
* `QMetaObject::newInstance()` constructs a new instance of the class.

It is also possible to perform dynamic casts using `qobject_cast()` on `QObject` classes. 
The `qobject_cast()` function behaves similarly to the standard C++ `dynamic_cast()`, with the advantages that it doesn't require RTTI support and it works across dynamic library boundaries. 
It attempts to cast its argument to the pointer type specified in angle-brackets, returning a non-zero pointer if the object is of the correct type (determined at run-time), or `nullptr` if the object's type is incompatible.

For example, let's assume `MyWidget` inherits from `QWidget` and is declared with the `Q_OBJECT` macro:
```c++
    QObject *obj = new MyWidget;
```
The `obj` variable, of type `QObject *`, actually refers to a `MyWidget` object, so we can cast it appropriately:
```c++
    QWidget *widget = qobject_cast<QWidget *>(obj);
```
The cast from `QObject` to `QWidget` is successful, because the object is actually a `MyWidget`, which is a subclass of `QWidget`. 
Since we know that `obj` is a `MyWidget`, we can also cast it to `MyWidget *`:
```c++
    MyWidget *myWidget = qobject_cast<MyWidget *>(obj);
```
The cast to `MyWidget` is successful because `qobject_cast()` makes no distinction between built-in Qt types and custom types.
```c++
    QLabel *label = qobject_cast<QLabel *>(obj);
    // label is 0
```
The cast to `QLabel`, on the other hand, fails. 
The pointer is then set to 0. 
This makes it possible to handle objects of different types differently at run-time, based on the type:
```c++
    if (QLabel *label = qobject_cast<QLabel *>(obj)) {
        label->setText(tr("Ping"));
    } else if (QPushButton *button = qobject_cast<QPushButton *>(obj)) {
        button->setText(tr("Pong!"));
    }
```

While it is possible to use `QObject` as a base class without the `Q_OBJECT` macro and without meta-object code, neither signals and slots nor the other features described here will be available if the `Q_OBJECT` macro is not used. 
From the meta-object system's point of view, a `QObject` subclass without meta code is equivalent to its closest ancestor with meta-object code. 
This means for example, that `QMetaObject::className()` will not return the actual name of your class, but the class name of this ancestor.

Therefore, we strongly recommend that all subclasses of QObject use the `Q_OBJECT` macro regardless of whether or not they actually use signals, slots, and properties.


See also QMetaObject, Qt's Property System, and Signals and Slots.


https://doc.qt.io/qt-6.2/qmetaobject.html










# The Property System


Qt provides a sophisticated property system similar to the ones supplied by some compiler vendors.
However, as a compiler- and platform-independent library, Qt does not rely on non-standard compiler features like `__property` or `[property]`. 
The Qt solution works with any standard C++ compiler on every platform Qt supports. 
It is based on the Meta-Object System that also provides inter-object communication via signals and slots.

## Requirements for Declaring Properties
To declare a property, use the `Q_PROPERTY()` macro in a class that inherits QObject.
```c++
Q_PROPERTY(type name
           (READ getFunction [WRITE setFunction] |
            MEMBER memberName [(READ getFunction | WRITE setFunction)])
           [RESET resetFunction]
           [NOTIFY notifySignal]
           [REVISION int | REVISION(int[, int])]
           [DESIGNABLE bool]
           [SCRIPTABLE bool]
           [STORED bool]
           [USER bool]
           [BINDABLE bindableProperty]
           [CONSTANT]
           [FINAL]
           [REQUIRED])
```
Here are some typical examples of property declarations taken from class QWidget.
```c++
Q_PROPERTY(bool focus READ hasFocus)
Q_PROPERTY(bool enabled READ isEnabled WRITE setEnabled)
Q_PROPERTY(QCursor cursor READ cursor WRITE setCursor RESET unsetCursor)
```
Here is an example showing how to export member variables as Qt properties using the `MEMBER` keyword. 
Note that a `NOTIFY` signal must be specified to allow QML property bindings.
```c++
    Q_PROPERTY(QColor color MEMBER m_color NOTIFY colorChanged)
    Q_PROPERTY(qreal spacing MEMBER m_spacing NOTIFY spacingChanged)
    Q_PROPERTY(QString text MEMBER m_text NOTIFY textChanged)
    ...
signals:
    void colorChanged();
    void spacingChanged();
    void textChanged(const QString &newText);

private:
    QColor  m_color;
    qreal   m_spacing;
    QString m_text;
```
A property behaves like a class data member, but it has additional features accessible through the Meta-Object System.
* A `READ` accessor function is required if no `MEMBER` variable was specified. 
	* It is for reading the property value.
	* Ideally, a const function is used for this purpose, and it must return either the property's type or a const reference to that type. e.g., `QWidget::focus` is a read-only property with READ function, `QWidget::hasFocus()`.
* A `WRITE` accessor function is optional. 
	* It is for setting the property value. 
	* It must return void and must take exactly one argument, either of the property's type or a pointer or reference to that type. e.g., `QWidget::enabled` has the WRITE function `QWidget::setEnabled()`.
	* Read-only properties do not need `WRITE` functions. 
	* e.g., `QWidget::focus` has no `WRITE` function.
* A `MEMBER` variable association is required if no `READ` accessor function is specified. 
	* This makes the given member variable readable and writable without the need of creating READ and WRITE accessor functions. 
	* It's still possible to use `READ` or `WRITE` accessor functions in addition to `MEMBER` variable association (but not both), if you need to control the variable access.
* A `RESET` function is optional.
	*  It is for setting the property back to its context specific default value. e.g., `QWidget::cursor` has the typical READ and WRITE functions, `QWidget::cursor()` and `QWidget::setCursor()`, and it also has a RESET function, `QWidget::unsetCursor()`, since no call to `QWidget::setCursor()` can mean reset to the context specific cursor. 
	*  The `RESET` function must return void and take no parameters.
* A `NOTIFY` signal is optional. 
	* If defined, it should specify one existing signal in that class that is emitted whenever the value of the property changes. 
	* `NOTIFY` signals for MEMBER variables must take zero or one parameter, which must be of the same type as the property. 
	* The parameter will take the new value of the property. 
	* The `NOTIFY` signal should only be emitted when the property has really been changed, to avoid bindings being unnecessarily re-evaluated in QML, for example. 
	* Qt emits automatically that signal when needed for `MEMBER` properties that do not have an explicit setter.
* A `REVISION` number or `REVISION()` macro is optional. 
	* If included, it defines the property and its notifier signal to be used in a particular revision of the API (usually for exposure to QML).
	*  If not included, it defaults to 0.
* The `DESIGNABLE` attribute indicates whether the property should be visible in the property editor of GUI design tool (e.g., Qt Designer). 
	* Most properties are `DESIGNABLE` (default true). Valid values are true and false.
* The `SCRIPTABLE` attribute indicates whether this property should be accessible by a scripting engine (default true). 
	* Valid values are true and false.
* The `STORED` attribute indicates whether the property should be thought of as existing on its own or as depending on other values. 
	* It also indicates whether the property value must be saved when storing the object's state. 
	* Most properties are `STORED` (default true), but e.g., `QWidget::minimumWidth()` has `STORED` false, because its value is just taken from the width component of property `QWidget::minimumSize()`, which is a QSize.
* The `USER` attribute indicates whether the property is designated as the user-facing or user-editable property for the class. 
	* Normally, there is only one `USER` property per class (default false). e.g., `QAbstractButton::checked` is the user editable property for (checkable) buttons. 
	* Note that QItemDelegate gets and sets a widget's `USER` property.
* The `BINDABLE bindableProperty` attribute indicates that the property supports bindings, and that it is possible to set and inspect bindings to this property via the meta object system (`QMetaProperty`). 
	* `bindableProperty` names a class member of type `QBindable<T>`, where T is the property type.
	* This attribute was introduced in Qt 6.0.
* The presence of the `CONSTANT` attribute indicates that the property value is constant. 
	* For a given object instance, the `READ` method of a constant property must return the same value every time it is called. 
	* This constant value may be different for different instances of the object. 
	* A constant property cannot have a `WRITE` method or a `NOTIFY` signal.
* The presence of the `FINAL` attribute indicates that the property will not be overridden by a derived class. 
	* This can be used for performance optimizations in some cases, but is not enforced by moc. 
	* Care must be taken never to override a `FINAL` property.
* The presence of the `REQUIRED` attribute indicates that the property should be set by a user of the class. 
	* This is not enforced by moc, and is mostly useful for classes exposed to QML. 
	* In QML, classes with `REQUIRED` properties cannot be instantiated unless all `REQUIRED` properties have been set.


The `READ`, `WRITE`, and `RESET` functions can be inherited. 
They can also be virtual. 
When they are inherited in classes where multiple inheritance is used, they must come from the first inherited class.

The property type can be any type supported by `QVariant`, or it can be a user-defined type. 
In this example, class `QDate` is considered to be a user-defined type.
```c++
Q_PROPERTY(QDate date READ getDate WRITE setDate)
```
Because `QDate` is user-defined, you must include the `<QDate>` header file with the property declaration.

For historical reasons, `QMap` and `QList` as property types are synonym of `QVariantMap` and `QVariantList`.

## Reading and Writing Properties with the Meta-Object System
A property can be read and written using the generic functions `QObject::property()` and `QObject::setProperty()`, without knowing anything about the owning class except the property's name. 
In the code snippet below, the call to `QAbstractButton::setDown()` and the call to `QObject::setProperty()` both set property "down".
```c++
QPushButton *button = new QPushButton;
QObject *object = button;

button->setDown(true);
object->setProperty("down", true);
```
Accessing a property through its `WRITE` accessor is the better of the two, because it is faster and gives better diagnostics at compile time, but setting the property this way requires that you know about the class at compile time. 
Accessing properties by name lets you access classes you don't know about at compile time. 
You can discover a class's properties at run time by querying its `QObject`, `QMetaObject`, and `QMetaProperties`.
```c++
QObject *object = ...
const QMetaObject *metaobject = object->metaObject();
int count = metaobject->propertyCount();
for (int i=0; i<count; ++i) {
    QMetaProperty metaproperty = metaobject->property(i);
    const char *name = metaproperty.name();
    QVariant value = object->property(name);
    ...
}
```
In the above snippet, `QMetaObject::property()` is used to get metadata about each property defined in some unknown class. 
The property name is fetched from the metadata and passed to `QObject::property()` to get the value of the property in the current object.

## A Simple Example
Suppose we have a class `MyClass`, which is derived from `QObject` and which uses the `Q_OBJECT` macro in its private section. 
We want to declare a property in `MyClass` to keep track of a priority value. 
The name of the property will be priority, and its type will be an enumeration type named `Priority`, which is defined in `MyClass`.

We declare the property with the `Q_PROPERTY()` macro in the private section of the class. 
The required `READ` function is named priority, and we include a `WRITE` function named `setPriority`.
The enumeration type must be registered with the Meta-Object System using the `Q_ENUM()` macro. 
Registering an enumeration type makes the enumerator names available for use in calls to `QObject::setProperty()`. 
We must also provide our own declarations for the `READ` and `WRITE` functions. 
The declaration of `MyClass` then might look like this:
```c++
class MyClass : public QObject
{
    Q_OBJECT
    Q_PROPERTY(Priority priority READ priority WRITE setPriority NOTIFY priorityChanged)

public:
    MyClass(QObject *parent = nullptr);
    ~MyClass();

    enum Priority { High, Low, VeryHigh, VeryLow };
    Q_ENUM(Priority)
    
    void setPriority(Priority priority)
    {
        m_priority = priority;
        emit priorityChanged(priority);
    }
    Priority priority() const
    { return m_priority; }

signals:
    void priorityChanged(Priority);

private:
    Priority m_priority;
};
```

The `READ` function is const and returns the property type. 
The `WRITE` function returns void and has exactly one parameter of the property type. 
The meta-object compiler enforces these requirements.

Given a pointer to an instance of `MyClass` or a pointer to a `QObject` that is an instance of `MyClass`, we have two ways to set its priority property:
```c++
MyClass *myinstance = new MyClass;
QObject *object = myinstance;

myinstance->setPriority(MyClass::VeryHigh);
object->setProperty("priority", "VeryHigh");
```
In the example, the enumeration type that is the property type is declared in `MyClass` and registered with the Meta-Object System using the `Q_ENUM()` macro. 
This makes the enumeration values available as strings for use as in the call to `setProperty()`. 
Had the enumeration type been declared in another class, its fully qualified name (i.e., `OtherClass::Priority`) would be required, and that other class would also have to inherit `QObject` and register the enumeration type there using the `Q_ENUM()` macro.

A similar macro, `Q_FLAG()`, is also available. 
Like `Q_ENUM()`, it registers an enumeration type, but it marks the type as being a set of flags, i.e. values that can be OR'd together. 
An I/O class might have enumeration values `Read` and `Write` and then `QObject::setProperty()` could accept `Read | Write`. 
`Q_FLAG()` should be used to register this enumeration type.

## Dynamic Properties
`QObject::setProperty()` can also be used to add new properties to an instance of a class at runtime. 
When it is called with a name and a value, if a property with the given name exists in the `QObject`, and if the given value is compatible with the property's type, the value is stored in the property, and true is returned. 
If the value is not compatible with the property's type, the property is not changed, and false is returned. 
But if the property with the given name doesn't exist in the `QObject` (i.e., if it wasn't declared with `Q_PROPERTY()`), a new property with the given name and value is automatically added to the `QObject`, but false is still returned. 
This means that a return of false can't be used to determine whether a particular property was actually set, unless you know in advance that the property already exists in the `QObject`.

Note that dynamic properties are added on a per instance basis, i.e., they are added to `QObject`, not `QMetaObject`.
A property can be removed from an instance by passing the property name and an invalid `QVariant` value to `QObject::setProperty()`. 
The default constructor for `QVariant` constructs an invalid `QVariant`.

Dynamic properties can be queried with `QObject::property()`, just like properties declared at compile time with `Q_PROPERTY()`.

## Properties and Custom Types
Custom types used by properties need to be registered using the `Q_DECLARE_METATYPE()` macro so that their values can be stored in `QVariant` objects. 
This makes them suitable for use with both static properties declared using the `Q_PROPERTY()` macro in class definitions and dynamic properties created at run-time.

## Adding Additional Information to a Class
Connected to the property system is an additional macro, `Q_CLASSINFO()`, that can be used to attach additional name--value pairs to a class's meta-object, for example:
```c++
Q_CLASSINFO("Version", "3.0.0")
```
Like other meta-data, class information is accessible at run-time through the meta-object; see `QMetaObject::classInfo()` for details.

## Using Bindable Properties
Three different types can be used to implement bindable properties:
* QProperty
* QObjectBindableProperty
* QObjectComputedProperty.

The first one is a general class for bindable properties. 
The latter two can only be used inside a `QObject`.

For more information, including examples, see the classes mentioned above and the general tips on implementing and using **bindable properties**.


https://doc.qt.io/qt-6.2/bindableproperties.html


See also 
Meta-Object System, 
Signals and Slots, 
Q_DECLARE_METATYPE(), 
QMetaType, 
QVariant, 
and Qt Bindable Properties.







# Object Model



The standard C++ object model provides very efficient runtime support for the object paradigm. 
But its static nature is inflexibile in certain problem domains. 
Graphical user interface programming is a domain that requires both runtime efficiency and a high level of flexibility. 
Qt provides this, by combining the speed of C++ with the flexibility of the Qt Object Model.

Qt adds these features to C++:
* a very powerful mechanism for seamless object communication called signals and slots
* queryable and designable object properties
* powerful events and event filters
* contextual string translation for internationalization
* sophisticated interval driven timers that make it possible to elegantly integrate many tasks in an event-driven GUI
* hierarchical and queryable object trees that organize object ownership in a natural way
* guarded pointers (QPointer) that are automatically set to 0 when the referenced object is destroyed, unlike normal C++ pointers which become dangling pointers when their objects are destroyed
* a dynamic cast that works across library boundaries.
* support for custom type creation.


Many of these Qt features are implemented with standard C++ techniques, based on inheritance from `QObject`.
Others, like the object communication mechanism and the dynamic property system, require the Meta-Object System provided by Qt's own Meta-Object Compiler (moc).

The meta-object system is a C++ extension that makes the language better suited to true component GUI programming.


## Important Classes
These classes form the basis of the Qt Object Model.
* `QMetaClassInfo`
Additional information about a class
* `QMetaEnum`
Meta-data about an enumerator
* `QMetaMethod`
Meta-data about a member function
* `QMetaObject`
Contains meta-information about Qt objects
* `QMetaProperty`
Meta-data about a property
* `QMetaSequence`
Allows type erased access to sequential containers
* `QMetaType`
Manages named types in the meta-object system
* `QObject`
The base class of all Qt objects
* `QObjectCleanupHandler`
Watches the lifetime of multiple QObjects
* `QPointer`
Template class that provides guarded pointers to QObject
* `QSignalBlocker`
Exception-safe wrapper around `QObject::blockSignals()`
* `QSignalMapper`
Bundles signals from identifiable senders
* `QVariant`
Acts like a union for the most common Qt data types



## Qt Objects: Identity vs Value
Some of the added features listed above for the Qt Object Model, require that we think of Qt Objects as identities, not values. 
Values are copied or assigned; identities are cloned. 
Cloning means to create a new identity, not an exact copy of the old one. 
For example, twins have different identities. 
They may look identical, but they have different names, different locations, and may have completely different social networks.

Then cloning an identity is a more complex operation than copying or assigning a value. 
We can see what this means in the Qt Object Model.

A Qt Object...
* might have a unique `QObject::objectName()`. 
	* If we copy a Qt Object, what name should we give the copy?
* has a location in an object hierarchy. 
	* If we copy a Qt Object, where should the copy be located?
* can be connected to other Qt Objects to emit signals to them or to receive signals emitted by them. 
	* If we copy a Qt Object, how should we transfer these connections to the copy?
* can have new properties added to it at runtime that are not declared in the C++ class.
	* If we copy a Qt Object, should the copy include the properties that were added to the original?


For these reasons, Qt Objects should be treated as identities, not as values. 
Identities are cloned, not copied or assigned, and cloning an identity is a more complex operation than copying or assigning a value. 
Therefore, `QObject` and all subclasses of `QObject` (direct or indirect) have their copy constructor and assignment operator disabled.





# Object Trees & Ownership


## Overview
`QObjects` organize themselves in object trees. 
When you create a `QObject` with another object as parent, it's added to the parent's `children()` list, and is deleted when the parent is. 
It turns out that this approach fits the needs of GUI objects very well. 
For example, a `QShortcut` (keyboard shortcut) is a child of the relevant window, so when the user closes that window, the shortcut is deleted too.

`QQuickItem`, the basic visual element of the Qt Quick module, inherits from `QObject`, but has a concept of the visual parent which differs from that of the `QObject` parent. 
An item's visual parent may not necessarily be the same as its object parent. 
See Concepts - Visual Parent in Qt Quick for more details.

https://doc.qt.io/qt-6.2/qtquick-visualcanvas-visualparent.html


`QWidget`, the fundamental class of the Qt Widgets module, extends the parent-child relationship. 
A child normally also becomes a child widget, i.e. it is displayed in its parent's coordinate system and is graphically clipped by its parent's boundaries. 
For example, when the application deletes a message box after it has been closed, the message box's buttons and label are also deleted, just as we'd want, because the buttons and label are children of the message box.

You can also delete child objects yourself, and they will remove themselves from their parents.
For example, when the user removes a toolbar it may lead to the application deleting one of its `QToolBar` objects, in which case the tool bar's `QMainWindow` parent would detect the change and reconfigure its screen space accordingly.

The debugging functions `QObject::dumpObjectTree()` and `QObject::dumpObjectInfo()` are often useful when an application looks or acts strangely.

## Construction/Destruction Order of QObjects
When `QObject`s are created on the heap (i.e., created with new), a tree can be constructed from them in any order, and later, the objects in the tree can be destroyed in any order. 
When any `QObject` in the tree is deleted, if the object has a parent, the destructor automatically removes the object from its parent. 
If the object has children, the destructor automatically deletes each child. 
No `QObject` is deleted twice, regardless of the order of destruction.

When `QObject`s are created on the stack, the same behavior applies. 
Normally, the order of destruction still doesn't present a problem. 
Consider the following snippet:
```c++
int main()
{
    QWidget window;
    QPushButton quit("Quit", &window);
    ...
}
```

The parent, window, and the child, quit, are both `QObject`s because `QPushButton` inherits `QWidget`, and `QWidget` inherits `QObject`.
This code is correct: the destructor of quit is not called twice because the C++ language standard (ISO/IEC 14882:2003) specifies that destructors of local objects are called in the reverse order of their constructors. 
Therefore, the destructor of the child, quit, is called first, and it removes itself from its parent, window, before the destructor of window is called.

But now consider what happens if we swap the order of construction, as shown in this second snippet:
```c++
int main()
{
    QPushButton quit("Quit");
    QWidget window;

    quit.setParent(&window);
    ...
}
```
In this case, the order of destruction causes a problem. 
The parent's destructor is called first because it was created last. It then calls the destructor of its child, quit, which is incorrect because quit is a local variable. 
When quit subsequently goes out of scope, its destructor is called again, this time correctly, but the damage has already been done.








# Signals & Slots

Signals and slots are used for communication between objects. 
The signals and slots mechanism is a central feature of Qt and probably the part that differs most from the features provided by other frameworks. 
Signals and slots are made possible by Qt's meta-object system.

## Introduction
In GUI programming, when we change one widget, we often want another widget to be notified. 
More generally, we want objects of any kind to be able to communicate with one another. 
For example, if a user clicks a Close button, we probably want the window's `close()` function to be called.

Other toolkits achieve this kind of communication using callbacks.
A callback is a pointer to a function, so if you want a processing function to notify you about some event you pass a pointer to another function (the callback) to the processing function. 
The processing function then calls the callback when appropriate. 
While successful frameworks using this method do exist, callbacks can be unintuitive and may suffer from problems in ensuring the type-correctness of callback arguments.

## Signals and Slots
In Qt, we have an alternative to the callback technique: We use signals and slots. 
A signal is emitted when a particular event occurs. 
Qt's widgets have many predefined signals, but we can always subclass widgets to add our own signals to them. 
A slot is a function that is called in response to a particular signal. 
Qt's widgets have many pre-defined slots, but it is common practice to subclass widgets and add your own slots so that you can handle the signals that you are interested in.

<img src="./abstract-connections.png"/>


The signals and slots mechanism is type safe: The signature of a signal must match the signature of the receiving slot. 
(In fact a slot may have a shorter signature than the signal it receives because it can ignore extra arguments.) 
Since the signatures are compatible, the compiler can help us detect type mismatches when using the function pointer-based syntax. 
The string-based `SIGNAL` and `SLOT` syntax will detect type mismatches at runtime. 
Signals and slots are loosely coupled: A class which emits a signal neither knows nor cares which slots receive the signal. 
Qt's signals and slots mechanism ensures that if you connect a signal to a slot, the slot will be called with the signal's parameters at the right time. 
Signals and slots can take any number of arguments of any type. 
They are completely type safe.

All classes that inherit from `QObject` or one of its subclasses (e.g., `QWidget`) can contain signals and slots. 
Signals are emitted by objects when they change their state in a way that may be interesting to other objects. 
This is all the object does to communicate.
It does not know or care whether anything is receiving the signals it emits. 
This is true information encapsulation, and ensures that the object can be used as a software component.

Slots can be used for receiving signals, but they are also normal member functions. 
Just as an object does not know if anything receives its signals, a slot does not know if it has any signals connected to it. 
This ensures that truly independent components can be created with Qt.

You can connect as many signals as you want to a single slot, and a signal can be connected to as many slots as you need.
It is even possible to connect a signal directly to another signal. 
(This will emit the second signal immediately whenever the first is emitted.)

Together, signals and slots make up a powerful component programming mechanism.

## Signals
Signals are emitted by an object when its internal state has changed in some way that might be interesting to the object's client or owner. 
Signals are public access functions and can be emitted from anywhere, but we recommend to only emit them from the class that defines the signal and its subclasses.

When a signal is emitted, the slots connected to it are usually executed immediately, just like a normal function call. 
When this happens, the signals and slots mechanism is totally independent of any GUI event loop. 
Execution of the code following the emit statement will occur once all slots have returned. 
The situation is slightly different when using queued connections; in such a case, the code following the emit keyword will continue immediately, and the slots will be executed later.

If several slots are connected to one signal, the slots will be executed one after the other, in the order they have been connected, when the signal is emitted.

Signals are automatically generated by the moc and must not be implemented in the `.cpp` file. 
They can never have return types (i.e. use void).

A note about arguments: Our experience shows that signals and slots are more reusable if they do not use special types. 
If `QScrollBar::valueChanged()` were to use a special type such as the hypothetical `QScrollBar::Range`, it could only be connected to slots designed specifically for `QScrollBar`. 
Connecting different input widgets together would be impossible.

## Slots
A slot is called when a signal connected to it is emitted. 
Slots are normal C++ functions and can be called normally; their only special feature is that signals can be connected to them.

Since slots are normal member functions, they follow the normal C++ rules when called directly. 
However, as slots, they can be invoked by any component, regardless of its access level, via a signal-slot connection. 
This means that a signal emitted from an instance of an arbitrary class can cause a private slot to be invoked in an instance of an unrelated class.

You can also define slots to be virtual, which we have found quite useful in practice.

Compared to callbacks, signals and slots are slightly slower because of the increased flexibility they provide, although the difference for real applications is insignificant. 
In general, emitting a signal that is connected to some slots, is approximately ten times slower than calling the receivers directly, with non-virtual function calls. 
This is the overhead required to locate the connection object, to safely iterate over all connections (i.e. checking that subsequent receivers have not been destroyed during the emission), and to marshall any parameters in a generic fashion.
While ten non-virtual function calls may sound like a lot, it's much less overhead than any new or delete operation, for example.
As soon as you perform a string, vector or list operation that behind the scene requires new or delete, the signals and slots overhead is only responsible for a very small proportion of the complete function call costs. 
The same is true whenever you do a system call in a slot; or indirectly call more than ten functions. 
The simplicity and flexibility of the signals and slots mechanism is well worth the overhead, which your users won't even notice.

Note that other libraries that define variables called signals or slots may cause compiler warnings and errors when compiled alongside a Qt-based application.
To solve this problem, #undef the offending preprocessor symbol.

## A Small Example
A minimal C++ class declaration might read:
```c++
class Counter
{
public:
    Counter() { m_value = 0; }

    int value() const { return m_value; }
    void setValue(int value);

private:
    int m_value;
};
```
A small QObject-based class might read:
```c++
#include <QObject>

class Counter : public QObject
{
    Q_OBJECT

public:
    Counter() { m_value = 0; }

    int value() const { return m_value; }

public slots:
    void setValue(int value);

signals:
    void valueChanged(int newValue);

private:
    int m_value;
};
```
The QObject-based version has the same internal state, and provides public methods to access the state, but in addition it has support for component programming using signals and slots. 
This class can tell the outside world that its state has changed by emitting a signal, `valueChanged()`, and it has a slot which other objects can send signals to.

All classes that contain signals or slots must mention `Q_OBJECT` at the top of their declaration. 
They must also derive (directly or indirectly) from `QObject`.

Slots are implemented by the application programmer. 
Here is a possible implementation of the `Counter::setValue()` slot:
```c++
void Counter::setValue(int value)
{
    if (value != m_value) {
        m_value = value;
        emit valueChanged(value);
    }
}
```
The `emit` line emits the signal `valueChanged()` from the object, with the new value as argument.

In the following code snippet, we create two `Counter` objects and connect the first object's `valueChanged()` signal to the second object's `setValue()` slot using `QObject::connect()`:
```c++
    Counter a, b;
    QObject::connect(&a, &Counter::valueChanged,
                     &b, &Counter::setValue);

    a.setValue(12);     // a.value() == 12, b.value() == 12
    b.setValue(48);     // a.value() == 12, b.value() == 48
```
Calling `a.setValue(12)` makes `a` emit a `valueChanged(12)` signal, which `b` will receive in its `setValue()` slot, i.e. `b.setValue(12)` is called. 
Then `b` emits the same `valueChanged()` signal, but since no slot has been connected to `b`'s `valueChanged()` signal, the signal is ignored.

Note that the `setValue()` function sets the value and emits the signal only if `value != m_value`.
This prevents infinite looping in the case of cyclic connections (e.g., if `b.valueChanged()` were connected to `a.setValue()`).

By default, for every connection you make, a signal is emitted; two signals are emitted for duplicate connections. 
You can break all of these connections with a single `disconnect()` call. 
If you pass the `Qt::UniqueConnection` type, the connection will only be made if it is not a duplicate. 
If there is already a duplicate (exact same signal to the exact same slot on the same objects), the connection will fail and connect will return false.

This example illustrates that objects can work together without needing to know any information about each other. 
To enable this, the objects only need to be connected together, and this can be achieved with some simple `QObject::connect()` function calls, or with uic's automatic connections feature.

## A Real Example
The following is an example of the header of a simple widget class without member functions. 
The purpose is to show how you can utilize signals and slots in your own applications.
```c++
#ifndef LCDNUMBER_H
#define LCDNUMBER_H

#include <QFrame>

class LcdNumber : public QFrame
{
    Q_OBJECT
```
`LcdNumber` inherits `QObject`, which has most of the signal-slot knowledge, via `QFrame` and `QWidget`.
It is somewhat similar to the built-in `QLCDNumber` widget.

The `Q_OBJECT` macro is expanded by the preprocessor to declare several member functions that are implemented by the moc; if you get compiler errors along the lines of "undefined reference to vtable for `LcdNumber`", you have probably forgotten to run the moc or to include the moc output in the link command.
```c++
public:
    LcdNumber(QWidget *parent = nullptr);

signals:
    void overflow();
```
After the class constructor and public members, we declare the class signals. 
The `LcdNumber` class emits a signal, `overflow()`, when it is asked to show an impossible value.

If you don't care about overflow, or you know that overflow cannot occur, you can ignore the `overflow()` signal, i.e. don't connect it to any slot.

If on the other hand you want to call two different error functions when the number overflows, simply connect the signal to two different slots. 
Qt will call both (in the order they were connected).
```c++
public slots:
    void display(int num);
    void display(double num);
    void display(const QString &str);
    void setHexMode();
    void setDecMode();
    void setOctMode();
    void setBinMode();
    void setSmallDecimalPoint(bool point);
};

#endif
```
A slot is a receiving function used to get information about state changes in other widgets. 
`LcdNumber` uses it, as the code above indicates, to set the displayed number. 
Since `display()` is part of the class's interface with the rest of the program, the slot is public.

Several of the example programs connect the `valueChanged()` signal of a `QScrollBar` to the `display()` slot, so the LCD number continuously shows the value of the scroll bar.

Note that `display()` is overloaded; Qt will select the appropriate version when you connect a signal to the slot. 
With callbacks, you'd have to find five different names and keep track of the types yourself.

## Signals And Slots With Default Arguments
The signatures of signals and slots may contain arguments, and the arguments can have default values. 
Consider `QObject::destroyed()`:
```c++
void destroyed(QObject* = nullptr);
```
When a `QObject` is deleted, it emits this `QObject::destroyed()` signal. 
We want to catch this signal, wherever we might have a dangling reference to the deleted `QObject`, so we can clean it up. 
A suitable slot signature might be:
```c++
void objectDestroyed(QObject* obj = nullptr);
```
To connect the signal to the slot, we use `QObject::connect()`.
There are several ways to connect signal and slots. 
The first is to use function pointers:
```c++
connect(sender, &QObject::destroyed, this, &MyObject::objectDestroyed);
```
There are several advantages to using `QObject::connect()` with function pointers. 
First, it allows the compiler to check that the signal's arguments are compatible with the slot's arguments. 
Arguments can also be implicitly converted by the compiler, if needed.

You can also connect to functors or C++11 lambdas:
```c++
connect(sender, &QObject::destroyed, this, [=](){ this->m_objects.remove(sender); });
```
In both these cases, we provide this as context in the call to `connect()`.
The context object provides information about in which thread the receiver should be executed. 
This is important, as providing the context ensures that the receiver is executed in the context thread.

The lambda will be disconnected when the sender or context is destroyed. 
You should take care that any objects used inside the functor are still alive when the signal is emitted.

The other way to connect a signal to a slot is to use `QObject::connect()` and the `SIGNAL` and `SLOT` macros. 
The rule about whether to include arguments or not in the `SIGNAL()` and `SLOT()` macros, if the arguments have default values, is that the signature passed to the `SIGNAL()` macro must not have fewer arguments than the signature passed to the `SLOT()` macro.

All of these would work:
```c++
connect(sender, SIGNAL(destroyed(QObject*)), this, SLOT(objectDestroyed(Qbject*)));
connect(sender, SIGNAL(destroyed(QObject*)), this, SLOT(objectDestroyed()));
connect(sender, SIGNAL(destroyed()), this, SLOT(objectDestroyed()));
```
But this one won't work:
```c++
connect(sender, SIGNAL(destroyed()), this, SLOT(objectDestroyed(QObject*)));
```
...because the slot will be expecting a `QObject` that the signal will not send. 
This connection will report a runtime error.

Note that signal and slot arguments are not checked by the compiler when using this `QObject::connect()` overload.

## Advanced Signals and Slots Usage
For cases where you may require information on the sender of the signal, Qt provides the `QObject::sender()` function, which returns a pointer to the object that sent the signal.

Lambda expressions are a convenient way to pass custom arguments to a slot:
```c++
connect(action, &QAction::triggered, engine,
        [=]() { engine->processAction(action->text()); });
```

## Using Qt with 3rd Party Signals and Slots
It is possible to use Qt with a 3rd party signal/slot mechanism. You can even use both mechanisms in the same project.
To do that, write the following into your CMake project file:
```cmake
target_compile_definitions(my_app PRIVATE QT_NO_KEYWORDS)
```

In a qmake project (.pro) file, you need to write:
```qmake
CONFIG += no_keywords
```
It tells Qt not to define the moc keywords signals, slots, and emit, because these names will be used by a 3rd party library, e.g. Boost. 
Then to continue using Qt signals and slots with the `no_keywords` flag, simply replace all uses of the Qt moc keywords in your sources with the corresponding Qt macros `Q_SIGNALS` (or `Q_SIGNAL`), `Q_SLOTS` (or `Q_SLOT`), and `Q_EMIT`.

## Signals and slots in Qt-based libraries
The public API of Qt-based libraries should use the keywords `Q_SIGNALS` and `Q_SLOTS` instead of signals and slots. 
Otherwise it is hard to use such a library in a project that defines `QT_NO_KEYWORDS`.

To enforce this restriction, the library creator may set the preprocessor define `QT_NO_SIGNALS_SLOTS_KEYWORDS` when building the library.

This define excludes signals and slots without affecting whether other Qt-specific keywords can be used in the library implementation.

See also 
QLCDNumber, 
QObject::connect(), 
Digital Clock Example, 
Tetrix Example, 
Meta-Object System, 
and Qt's Property System.


